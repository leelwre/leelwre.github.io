<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leelwre</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://leelwre.github.io/"/>
  <updated>2020-07-03T03:58:33.836Z</updated>
  <id>http://leelwre.github.io/</id>
  
  <author>
    <name>leelwre</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://leelwre.github.io/uncategorized/hello-world.html"/>
    <id>http://leelwre.github.io/uncategorized/hello-world.html</id>
    <published>2020-07-03T03:58:33.836Z</published>
    <updated>2020-07-03T03:58:33.836Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>共空间模式（common spatial pattern, CSP)</title>
    <link href="http://leelwre.github.io/BCI/CSP.html"/>
    <id>http://leelwre.github.io/BCI/CSP.html</id>
    <published>2020-06-20T06:37:00.680Z</published>
    <updated>2020-07-04T03:26:26.506Z</updated>
    
    <content type="html"><![CDATA[<center><font face = "黑体" size = 6>__共空间模式滤波：一种脑电信号解码方法__</font></center># <font size = 4>摘要</font>&emsp;&emsp;空间滤波器对于分析脑电信号、提高信噪比非常有效。其中，共空间模式是最常用的一类空间滤波算法，尤其在运动想象范式分类上具有较好的效果，是运动想象范式的基准算法之一。因此，本文结合矩阵理论知识，从共空间模式的原始算法出发，逐步推导计算，并介绍其第二种表述形式，旨在阐明这一算法的数学思想，最后，结合少量模拟样本，更直观地展示了该算法的作用。# <font size = 4>一、问题及背景</font>&emsp;&emsp;肌萎缩性侧索硬化症(ALS)晚期患者或患有闭锁综合征的患者不能产生任何随意的肌肉运动，但这些疾病对大脑的感觉和认知功能影响很小，因此使用脑电图（electroencephalograph, EEG）来控制辅助设备为这些病人提供了一种与外界交流的可能方式[[1]](#1)。想象肢体运动可以改变脑电活动，这种实验范式称为运动想象（motor imagery, MI），根据运动想象的类型可以获得不同的脑电模式。一种简单的通过运动想象实现控制的方式为区分对左右手运动的想象。  &emsp;&emsp;由于容积传导效应的存在，原始的非侵入式脑电信号的空间分辨率较差，因此，为提高信噪比，空间滤波器在单次试验（trial）的分析中是非常有用的。# <font size = 4>二、方法</font>&emsp;&emsp;用于处理脑电信号的一经典空间滤波方法为共空间模式（common spatial pattern, CSP）。CSP通过数据驱动的有监督的方式将原始传感器空间中的脑电信号投影至一个新的空间，使得空间滤波后的信号在一种情况下（一个类别）的方差最大，而在另一种情况下（另一个类别）方差最小[[2]](#2)，即滤波后的数据包含了最有区分性的信息，因此在这之后很容易通过线性分类器分开。这也是CSP的根本原理。设计这种空间滤波器的方法是基于对两个协方差矩阵的同时对角化[[1]](#1)。  &emsp;&emsp;原始的单次试验的EEG数据可以表示为$E_l\in R^{N\times T}$和$E_r\in R^{N\times T}$，分别为想象左手运动与想象右手运动，其中$N$是通道（采集数据的电极）数目，$T$是采样点个数。预处理中的滤波去除了EEG中的常数部分，使得该分布的均值为0。# <font size = 3>2.1 CSP的原始形式</font><ol><li>首先按下式求得空间协方差矩阵并归一化。<br>$$C_l=\frac{E_lE_l^<em>}{trace(E_lE_l^</em>)}$$<br>$$C_r=\frac{E_rE_r^<em>}{trace(E_rE_r^</em>)}$$<br>显然，协方差矩阵$C_l与C_r$是Hermite矩阵，同时也是半正定矩阵，且Hermite矩阵的特征值均为实数。</li><li>然后构建复合协方差矩阵，并对其进行白化处理（Whitening)。<br>复合协方差矩阵为<br>$$C_c=C_l+C_r$$<br>为去除信号中的冗余信息，需进行白化处理。矩阵白化的作用主要体现在两方面：<ul><li>减少特征之间的相关性</li><li>使特征具有相同的方差  </li></ul></li></ol><p>&emsp;&emsp;以上作用可以通过构建一白化矩阵$P$，将复合协方差矩阵$C_c$变换为单位矩阵$I$表现出，这也是矩阵白化的方法，$i.e.P^<em>C_cP=I$。<br>&emsp;&emsp;因为$C_c$为Hermite矩阵，为正规矩阵，可以酉对角化，故$\exists$酉矩阵$V$，$V$为单位特征向量矩阵（每一列为特征向量），s.t.$$V^<em>C_cV=D=\begin{bmatrix}<br>\lambda_1^C &amp; &amp; &amp;\<br>&amp; \lambda_2^C &amp; &amp;\<br>&amp; &amp; \ddots &amp;\<br>&amp; &amp; &amp; \lambda_N^C<br>\end{bmatrix} $$<br>&emsp;&emsp;取白化矩阵$$\begin{equation} P=V^</em>D^{-1/2}\label{10} \end{equation}$$<br>&emsp;&emsp;则$$P^<em>C_cP=I$$<br>3. 计算空间滤波器$W$。<br>$$\begin{equation} I=P^</em>C_cP=P^<em>C_lP+P^</em>C_rP=S_l+S_r\label{100} \end{equation}$$<br>&emsp;&emsp;设$\lambda_j$为$S_l$的特征值，对应的特征向量为$v_j$，即<br>$$S_lv_j=\lambda_jv_j$$<br>&emsp;&emsp;又因为<br>$$S_l+S_r=I$$<br>&emsp;&emsp;所以<br>$$(I-S_r)v_j=\lambda_jv_j$$<br>&emsp;&emsp;上式可化为<br>$$S_r v_j=(1-\lambda_j)v_j$$<br>&emsp;&emsp;故$v_j$也是$S_r$的特征向量，而对应的特征值为$1-\lambda_j$。所以矩阵$S_l$与$S_r$具有相同的特征向量，而对应的特征值之和为1。因为$PCP^</em>=I$有相同的特征空间，所以这种方法称为共空间模式。<br>&emsp;&emsp;因为$S_l$与$S_r$均为Hermite矩阵，均可以酉对角化。<br>$$\begin{equation} S_l=UD_lU^<em>=U\begin{bmatrix}<br>\lambda_1 &amp; &amp; &amp;\<br>&amp; \lambda_2 &amp; &amp;\<br>&amp; &amp; \ddots &amp;\<br>&amp; &amp; &amp; \lambda_N<br>\end{bmatrix}U^*\label{101} \end{equation}$$<br>$$\begin{equation} S_r=UD_rU^</em>=U\begin{bmatrix}<br>1-\lambda_1 &amp; &amp; &amp;\<br>&amp; 1-\lambda_2 &amp; &amp;\<br>&amp; &amp; \ddots &amp;\<br>&amp; &amp; &amp; 1-\lambda_N<br>\end{bmatrix}U^<em>\label{102} \end{equation}$$<br>$$D_l+D_r=I$$<br>&emsp;&emsp;同时，协方差矩阵为半正定矩阵，半正定矩阵的特征值均为非负，所以$S_l$与$S_r$的特征值均在0～1之间。显然，对角阵$D_l$与$D_r$对角线上的元素（特征值）为白化后的EEG（$PE$）经矩阵$U$的线性变换后得到的新矩阵的方差，所以最大与最小的$\lambda_j$对应的特征向量可以将白化后的两类EEG数据旋转至最具区分性。<br>&emsp;&emsp;将式$\eqref{100}$分别与式$\eqref{101}, \eqref{102}$联立可得<br>$$PC_lP^</em>=UD_lU^<em>$$<br>$$PC_rP^</em>=UD_rU^<em>$$<br>&emsp;&emsp;所以<br>$$(P^<em>U)^</em>C_lP^<em>U=D_l$$<br>$$(P^</em>U)^<em>C_rP^</em>U=D_r$$<br>&emsp;&emsp;因此，对原始EEG数据$E_l$与$E_r$进行的整体线性变换为$(P^*U)^</em>$，$i.e.$空间滤波器$W=P^<em>U$，空间滤波后的矩阵为<br>$$Z=W^</em>E$$</p><h1 id="2-2-CSP的第二种表述"><a href="#2-2-CSP的第二种表述" class="headerlink" title="2.2 CSP的第二种表述"></a><font size = 3>2.2 CSP的第二种表述</font></h1><p>&emsp;&emsp;对以上推理过程进行总结，可得，CSP的计算思路是找到一个投影矩阵$W$将这两个类别的EEG信号的协方差矩阵$C_l$与$C_r$对角化，且使得两对角阵的和为单位矩阵，即<br>$$\begin{equation} W^<em>C_lW=D_l\label{11} \end{equation}$$<br>$$\begin{equation} W^*C_rW=D_r\label{12} \end{equation}$$<br>$$\begin{equation} D_l+D_r=I\label{13} \end{equation}$$<br>将$\eqref{11}$与$\eqref{12}$相加，并将$\eqref{13}$代入得<br>$$\begin{equation} W^</em>(C_l+C_r)W=D_l+D_r=I\label{14} \end{equation}$$<br>$\eqref{14}$与$\eqref{11}$联立得<br>$$\begin{equation} C_lW=(C_l+C_r)WD_l\label{16} \end{equation}$$<br>式$\eqref{16}$类似于特征向量的定义公式，实际上，若$C_l+C_r$可逆，则可将其移至左侧，得到<br>$$\begin{equation} (C_l+C_r)^{-1}C_lW=WD_l\label{17} \end{equation}$$<br>此时，式$\eqref{17}$恰为特征向量的定义公式。形如式$\eqref{16}$称为广义特征值问题。而在大部分情况下$C_l+C_r$是不可逆的，因此，接下来将推导广义特征值的求解。</p><h1 id="2-2-1-广义特征值问题"><a href="#2-2-1-广义特征值问题" class="headerlink" title="2.2.1 广义特征值问题"></a><font size = 3>2.2.1 广义特征值问题</font></h1><p>&emsp;&emsp;广义特征值问题是关于方程<br>$$\begin{equation} A\phi=\lambda B\phi\label{18} \end{equation}$$<br>求解数值$\lambda$，使得方程有非零解$\phi$。其中，$A, B$均为Hermite矩阵。方程$\eqref{18}$的矩阵形式为<br>$$\begin{equation} A\Phi=B\Phi\Lambda\label{22} \end{equation} $$<br>&emsp;&emsp;其中，$\Phi$与$\Lambda$分别为特征向量矩阵与特征值矩阵，求解广义特征值问题即为求解这两个矩阵。  </p><ul><li>$B$为正规矩阵，对其进行酉对角化<br>$$\begin{equation} U_B^*BU_B=\Lambda_B\label{19} \end{equation}$$</li><li>根据式$\eqref{10}$得到关于矩阵$B$的白化矩阵为<br>$$U_B’=U_B\Lambda_B^{-1/2}$$<br>&emsp;&emsp;使得<br>$$U_B’^* BU_B’=I$$<br>&emsp;&emsp;注意矩阵$U_B’$不是酉矩阵。</li><li>使用矩阵$U_B’$对矩阵$A$进行变换<br>$$U_B’^* AU_B’=(\Lambda_B^{-1/2}U_B^<em>)A(U_B\Lambda_B^{-1/2})=A’$$<br>注意因$A’^</em>=A’$，矩阵$A’$仍为Hermite矩阵。</li><li>$A’$为正规矩阵，对其进行酉对角化<br>$$U_A^<em>A’U_A=\Lambda$$<br>&emsp;&emsp;i.e.<br>$$\begin{equation} U_A^</em>(\Lambda_B^{-1/2}U_B^<em>AU_B\Lambda_B^{-1/2})U_A=(U_A^*\Lambda_B^{-1/2}U_B^</em>)A(U_B\Lambda_B^{-1/2}U_A)=\Phi^*A\Phi=\Lambda\label{20} \end{equation}$$<br>&emsp;&emsp;其中，定义<br>$$\Phi=U_B\Lambda_B^{-1/2}U_A$$<br>&emsp;&emsp;注意矩阵$\Phi$不是酉矩阵。</li><li>$U$也可以将矩阵$B$对角化<br>$$\begin{equation} \Phi^<em>B\Phi=(U_A^</em>\Lambda_B^{-1/2})U_B^<em>BU_B(\Lambda_B^{-1/2}U_A)=U_A^</em>\Lambda_B^{-1/2}\Lambda_B\Lambda_B^{-1/2}U_A=U_A^*U_A=I\label{21} \end{equation}$$</li><li>将式$\eqref{20}$和式$\eqref{21}$结合可得到<br>$$\left{\begin{matrix}<br>\Phi^<em>A\Phi=\Lambda(14)\<br>\Phi^</em>B\Phi=I(15)<br>\end{matrix}\right.$$<br>&emsp;&emsp;在式$\eqref{21}$的左右两边同时右乘$\Lambda$，并将$\eqref{20}$代入右边得到<br>$$A\Phi=B\Phi\Lambda$$<br>&emsp;&emsp;上式恰为式$\eqref{22}$。因此，广义特征值问题的解在以上推导过程中求出。</li></ul><h1 id="2-2-2-广义瑞利商"><a href="#2-2-2-广义瑞利商" class="headerlink" title="2.2.2 广义瑞利商"></a><font size = 3>2.2.2 广义瑞利商</font></h1><p>&emsp;&emsp;广义瑞利商的定义为<br>$$R(w)=\frac{w^<em>Aw}{w^<em>Bw}$$<br>&emsp;&emsp;其中，A, B均为Hermite矩阵，B为正定矩阵，$w\in C^n$。显然，对$w$进行等比例缩放不会影响瑞利商的值，i.e. $R(w)=R(cw), c\in R, c\neq 0$。<br>&emsp;&emsp;于是，可以确定合适的$w$，令$w^</em>Bw=1$，则$R(w)=w^<em>Aw$。此时，对$R(w)$求极值就是在约束$w^</em>Bw=1$条件下对$w^<em>Aw$求极值。利用拉格朗日乘子法求解，定义<br>$$L(w,\lambda)=w^</em>Aw-\lambda(w^<em>Bw-1)$$<br>&emsp;&emsp;然后求梯度取零<br>$$\frac{d}{dw}L=Aw-\lambda Bw=0$$<br>得到<br>$$Aw=\lambda Bw=\frac{w^</em>Aw}{w^<em>Bw}Bw$$<br>&emsp;&emsp;可以看出，上式与式$\eqref{18}$相同，即，寻找$w$使广义瑞利商$R(w)$最大可以等价为求解A与B的广义特征值问题，并找到使特征值$\lambda$最大所对应的特征向量$w$。<br>&emsp;&emsp;因此，之前得到的CSP的第二种表述（式$\eqref{16}$）可以也变形为求解广义瑞利商的最大值问题。<br>即<br>$$C_lW=(C_l+C_r)WD_l\Leftrightarrow \underset{w}{\mathrm{max}}\frac{w^</em>C_lw}{w^</em>(C_l+C_r)w}$$<br>&emsp;&emsp;其中，$W$矩阵是使广义瑞利商广义雷利商第一大、第二大至第N大的向量$w$组成的矩阵。</p><h1 id="三、数据及结果"><a href="#三、数据及结果" class="headerlink" title="三、数据及结果"></a><font size = 4>三、数据及结果</font></h1><p>&emsp;&emsp;因为脑电信号往往是高维的，且包含大量噪声与伪迹，预处理过程也将对分类效果产生较大影响。因此本文使用随机生成的二维数据作为CSP滤波的例子，来解释CSP是如何工作的，并验证以上推导的CSP的两种表述方式的一致性。本例使用python进行编程及可视化展示，代码见附录。<br>&emsp;&emsp;这两类数据是随机生成的高斯分布样本，具有相同的均值，协方差矩阵分别为<br>$$\begin{bmatrix}<br>10 &amp; -8\<br>-8 &amp;10<br>\end{bmatrix}, \begin{bmatrix}<br>20 &amp; -8\<br>-8 &amp;5<br>\end{bmatrix} $$<br>&emsp;&emsp;由此得到两组强相关但可分的数据，如图1左图所示。其中，两个椭圆表示的是每组数据的协方差，椭圆的旋转角度由协方差矩阵的特征向量得到，长短轴由协方差矩阵的特征值得到，因为特征向量表示椭圆长短轴的方向，而对应的特征值为轴的长度。使用以上两种方法分别计算可得到相同的投影矩阵。图中虚线为CSP投影的方向，这两个向量不是正交的，但他们与每一类最大方差的方向几乎是正交的。<br>右图为经过空间滤波后样本的分布，可以看出，这两类分布同时去相关，沿着纵轴红色类别具有最大的方差，而蓝色类别的方差最小；相反，沿着横轴蓝色类别具有最大的方差，而红色类别方差最小。<br><img src="/Users/lwre/Downloads/%E5%B0%8F%E8%AE%BA%E6%96%87/Figure_0.png" alt=""></p><center>图1 CSP空间滤波前后样本分布图</center><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><font size = 4>参考文献</font></h1><p><span id="1">[1]Ramoser H, Muller-Gerking J, Pfurtscheller G. Optimal spatial filtering of single trial EEG during imagined hand movement[J]. IEEE transactions on rehabilitation engineering, 2000, 8(4): 441-446.</span><br><span id="2">[2]Blankertz B, Tomioka R, Lemm S, et al. Optimizing spatial filters for robust EEG single-trial analysis[J]. IEEE Signal processing magazine, 2007, 25(1): 41-56.</span></p><h1 id="附录（代码）"><a href="#附录（代码）" class="headerlink" title="附录（代码）"></a><font size = 4>附录（代码）</font></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> linalg</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pdb <span class="keyword">import</span> set_trace</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Ellipse</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate data</span></span><br><span class="line">mean1 = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">mean2 = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">cov1 = [[<span class="number">10</span>,<span class="number">-8</span>],[<span class="number">-8</span>,<span class="number">10</span>]]</span><br><span class="line">cov2 = [[<span class="number">20</span>,<span class="number">-8</span>],[<span class="number">-8</span>,<span class="number">5</span>]]</span><br><span class="line">X1 = np.random.multivariate_normal(mean1, cov1, <span class="number">150</span>).T</span><br><span class="line">X2 = np.random.multivariate_normal(mean2, cov2, <span class="number">150</span>).T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X1 = X1 - X1.mean(axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)</span><br><span class="line">X2 = X2 - X2.mean(axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)</span><br><span class="line">X1 = np.mat(X1)</span><br><span class="line">X2 = np.mat(X2)</span><br><span class="line"><span class="comment"># normalization covariance</span></span><br><span class="line">C1 = (X1*X1.T)/np.trace(X1*X1.T)</span><br><span class="line">C2 = (X2*X2.T)/np.trace(X2*X2.T)</span><br><span class="line">C = C1 + C2</span><br><span class="line"></span><br><span class="line"><span class="comment"># method one</span></span><br><span class="line"><span class="comment">## whitening matrix</span></span><br><span class="line">D_c, V_c = linalg.eigh(C)</span><br><span class="line">isqrt_D_c = np.diag(np.sqrt(<span class="number">1</span>/D_c))</span><br><span class="line">P = np.mat(isqrt_D_c)*np.mat(V_c.T)</span><br><span class="line"></span><br><span class="line">S1 = P*C1*P.T</span><br><span class="line">S2 = P*C2*P.T</span><br><span class="line"><span class="comment">## spatial filters</span></span><br><span class="line">D1, V = linalg.eigh(S1)</span><br><span class="line">W = P.T*np.mat(V)</span><br><span class="line">print(W)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # method two</span></span><br><span class="line"><span class="comment"># D1, W1 = linalg.eigh(C1,C)</span></span><br><span class="line"><span class="comment"># print(W)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># projected data</span></span><br><span class="line">Z1 = W.T*X1</span><br><span class="line">Z2 = W.T*X2</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate covariance ellipse--raw data</span></span><br><span class="line">values1, vectors1 = linalg.eigh(C1)</span><br><span class="line">values2, vectors2 = linalg.eigh(C2)</span><br><span class="line">angle1 = math.degrees(math.atan(vectors1[<span class="number">0</span>][<span class="number">1</span>]/vectors1[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">angle2 = math.degrees(math.atan(vectors2[<span class="number">0</span>][<span class="number">1</span>]/vectors2[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">e1 = Ellipse(xy = (<span class="number">0</span>,<span class="number">0</span>), width = values1[<span class="number">0</span>]*<span class="number">10</span>, height = values1[<span class="number">1</span>]*<span class="number">10</span>, angle=angle1, edgecolor=<span class="string">'orange'</span>, fill = <span class="literal">False</span>, linewidth=<span class="number">2</span>, zorder=<span class="number">2</span>)</span><br><span class="line">e2 = Ellipse(xy = (<span class="number">0</span>,<span class="number">0</span>), width = values2[<span class="number">0</span>]*<span class="number">10</span>, height = values2[<span class="number">1</span>]*<span class="number">10</span>, angle=angle2, edgecolor=<span class="string">'c'</span>, fill = <span class="literal">False</span>, linewidth=<span class="number">2</span>, zorder=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate covariance ellipse--projected data</span></span><br><span class="line">C1 = (Z1*Z1.T)/np.trace(Z1*Z1.T)</span><br><span class="line">C2 = (Z2*Z2.T)/np.trace(Z2*Z2.T)</span><br><span class="line">values1, vectors1 = linalg.eigh(C1)</span><br><span class="line">values2, vectors2 = linalg.eigh(C2)</span><br><span class="line">angle1 = math.degrees(math.atan(vectors1[<span class="number">0</span>][<span class="number">1</span>]/vectors1[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">angle2 = math.degrees(math.atan(vectors2[<span class="number">0</span>][<span class="number">1</span>]/vectors2[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">after_e1 = Ellipse(xy = (<span class="number">0</span>,<span class="number">0</span>), width = values1[<span class="number">0</span>]*<span class="number">10</span>, height = values1[<span class="number">1</span>]*<span class="number">10</span>, angle=angle1, edgecolor=<span class="string">'orange'</span>, fill = <span class="literal">False</span>, linewidth=<span class="number">2</span>, zorder=<span class="number">2</span>)</span><br><span class="line">after_e2 = Ellipse(xy = (<span class="number">0</span>,<span class="number">0</span>), width = values2[<span class="number">0</span>]*<span class="number">10</span>, height = values2[<span class="number">1</span>]*<span class="number">10</span>, angle=angle2, edgecolor=<span class="string">'c'</span>, fill = <span class="literal">False</span>, linewidth=<span class="number">2</span>, zorder=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig = plt.figure(<span class="number">0</span>)</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">121</span>, aspect=<span class="string">'equal'</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">122</span>, aspect=<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line">ax1.plot(X1[<span class="number">0</span>],X1[<span class="number">1</span>],<span class="string">'ro'</span>)</span><br><span class="line">ax1.plot(X2[<span class="number">0</span>],X2[<span class="number">1</span>],<span class="string">'bo'</span>)</span><br><span class="line">ax1.add_artist(e1)</span><br><span class="line">ax1.add_artist(e2)</span><br><span class="line">ax1.set_xlim(<span class="number">-15</span>, <span class="number">15</span>)</span><br><span class="line">ax1.set_ylim(<span class="number">-15</span>, <span class="number">15</span>)</span><br><span class="line">ax1.grid(<span class="literal">True</span>)</span><br><span class="line">x = np.arange(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line">ax1.plot(x,W[<span class="number">0</span>][<span class="number">1</span>]/W[<span class="number">0</span>][<span class="number">0</span>]*x,<span class="string">'b--'</span>)</span><br><span class="line">ax1.plot(x,W[<span class="number">1</span>][<span class="number">1</span>]/W[<span class="number">1</span>][<span class="number">0</span>]*x,<span class="string">'r--'</span>)</span><br><span class="line">ax1.set_title(<span class="string">'Before CSP Filtering'</span>)</span><br><span class="line">ax1.plot()</span><br><span class="line"></span><br><span class="line">ax2.plot(Z1[<span class="number">0</span>],Z1[<span class="number">1</span>],<span class="string">'ro'</span>)</span><br><span class="line">ax2.plot(Z2[<span class="number">0</span>],Z2[<span class="number">1</span>],<span class="string">'bo'</span>)</span><br><span class="line">ax2.add_artist(after_e1)</span><br><span class="line">ax2.add_artist(after_e2)</span><br><span class="line">ax2.set_xlim(<span class="number">-15</span>, <span class="number">15</span>)</span><br><span class="line">ax2.set_ylim(<span class="number">-15</span>, <span class="number">15</span>)</span><br><span class="line">ax2.set_title(<span class="string">'After CSP Filtering'</span>)</span><br><span class="line">ax2.grid(<span class="literal">True</span>)</span><br><span class="line">ax2.plot()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;font face = &quot;黑体&quot; size = 6&gt;__共空间模式滤波：一种脑电信号解码方法__&lt;/font&gt;&lt;/center&gt;
# &lt;font size = 4&gt;摘要&lt;/font&gt;
&amp;emsp;&amp;emsp;空间滤波器对于分析脑电信号、提高信噪比非常有效。其中，
      
    
    </summary>
    
    
      <category term="BCI" scheme="http://leelwre.github.io/categories/BCI/"/>
    
    
  </entry>
  
</feed>
